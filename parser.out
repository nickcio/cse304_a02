Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DO

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> class_decl
Rule 3     program -> class_decl program
Rule 4     program -> empty
Rule 5     class_decl -> CLASS ID opt_extend LBRACK class_body_decl_mult RBRACK
Rule 6     opt_extend -> EXTENDS ID
Rule 7     opt_extend -> empty
Rule 8     class_body_decl_mult -> class_body_decl_mult class_body_decl
Rule 9     class_body_decl_mult -> class_body_decl
Rule 10    class_body_decl -> field_decl
Rule 11    class_body_decl -> method_decl
Rule 12    class_body_decl -> constructor_decl
Rule 13    field_decl -> modifier var_decl
Rule 14    modifier -> visibility opt_static
Rule 15    visibility -> PUBLIC
Rule 16    visibility -> PRIVATE
Rule 17    visibility -> empty
Rule 18    opt_static -> STATIC
Rule 19    opt_static -> empty
Rule 20    var_decl -> type variables SEMICOLON
Rule 21    type -> INT
Rule 22    type -> FLOAT
Rule 23    type -> BOOLEAN
Rule 24    type -> ID
Rule 25    variables -> variables COMMA variable
Rule 26    variables -> variable
Rule 27    variable -> ID
Rule 28    method_decl -> modifier type ID LPAREN opt_formals RPAREN block
Rule 29    method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block
Rule 30    opt_formals -> formals
Rule 31    opt_formals -> empty
Rule 32    constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block
Rule 33    opt_formals_alt -> formals
Rule 34    opt_formals_alt -> empty
Rule 35    formals -> formals COMMA formal_param
Rule 36    formals -> formal_param
Rule 37    formal_param -> type variable
Rule 38    block -> LBRACK stmt_mult RBRACK
Rule 39    stmt_mult -> stmt_mult stmt
Rule 40    stmt_mult -> empty
Rule 41    stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt
Rule 42    stmt -> WHILE LPAREN expr RPAREN stmt
Rule 43    stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt
Rule 44    stmt -> RETURN opt_expr SEMICOLON
Rule 45    stmt -> stmt_expr SEMICOLON
Rule 46    stmt -> BREAK SEMICOLON
Rule 47    stmt -> CONTINUE SEMICOLON
Rule 48    stmt -> block
Rule 49    stmt -> var_decl
Rule 50    stmt -> SEMICOLON
Rule 51    opt_else_stmt -> ELSE stmt
Rule 52    opt_else_stmt -> empty
Rule 53    opt_expr -> expr
Rule 54    opt_expr -> empty
Rule 55    opt_stmt_expr -> stmt_expr
Rule 56    opt_stmt_expr -> empty
Rule 57    literal -> INT_CONST
Rule 58    literal -> FLOAT_CONST
Rule 59    literal -> STRING_CONST
Rule 60    literal -> NULL
Rule 61    literal -> TRUE
Rule 62    literal -> FALSE
Rule 63    primary -> literal
Rule 64    primary -> THIS
Rule 65    primary -> SUPER
Rule 66    primary -> LPAREN expr RPAREN
Rule 67    primary -> NEW ID LPAREN opt_args RPAREN
Rule 68    primary -> lhs
Rule 69    primary -> method_invocation
Rule 70    opt_args -> arguments
Rule 71    opt_args -> empty
Rule 72    arguments -> arguments COMMA expr
Rule 73    arguments -> expr
Rule 74    lhs -> field_access
Rule 75    field_access -> primary DOT ID
Rule 76    field_access -> ID
Rule 77    method_invocation -> field_access LPAREN opt_args_alt RPAREN
Rule 78    opt_args_alt -> arguments
Rule 79    opt_args_alt -> empty
Rule 80    expr -> primary
Rule 81    expr -> assign
Rule 82    expr -> expr arith_op expr
Rule 83    expr -> expr bool_op expr
Rule 84    expr -> unary_op expr
Rule 85    assign -> lhs EQUALS expr
Rule 86    assign -> lhs DOUBLE_PLUS
Rule 87    assign -> DOUBLE_PLUS lhs
Rule 88    assign -> lhs DOUBLE_MINUS
Rule 89    assign -> DOUBLE_MINUS lhs
Rule 90    arith_op -> PLUS
Rule 91    arith_op -> MINUS
Rule 92    arith_op -> TIMES
Rule 93    arith_op -> DIVIDE
Rule 94    bool_op -> AND
Rule 95    bool_op -> OR
Rule 96    bool_op -> DOUBLE_EQUALS
Rule 97    bool_op -> NOT_EQUAL
Rule 98    bool_op -> L_EQ
Rule 99    bool_op -> G_EQ
Rule 100   bool_op -> LESS
Rule 101   bool_op -> GREATER
Rule 102   unary_op -> PLUS
Rule 103   unary_op -> MINUS
Rule 104   unary_op -> NOT
Rule 105   stmt_expr -> assign
Rule 106   stmt_expr -> method_invocation

Terminals, with rules where they appear

AND                  : 94
BOOLEAN              : 23
BREAK                : 46
CLASS                : 5
COMMA                : 25 35 72
CONTINUE             : 47
DIVIDE               : 93
DO                   : 
DOT                  : 75
DOUBLE_EQUALS        : 96
DOUBLE_MINUS         : 88 89
DOUBLE_PLUS          : 86 87
ELSE                 : 51
EQUALS               : 85
EXTENDS              : 6
FALSE                : 62
FLOAT                : 22
FLOAT_CONST          : 58
FOR                  : 43
GREATER              : 101
G_EQ                 : 99
ID                   : 5 6 24 27 28 29 32 67 75 76
IF                   : 41
INT                  : 21
INT_CONST            : 57
LBRACK               : 5 38
LESS                 : 100
LPAREN               : 28 29 32 41 42 43 66 67 77
L_EQ                 : 98
MINUS                : 91 103
NEW                  : 67
NOT                  : 104
NOT_EQUAL            : 97
NULL                 : 60
OR                   : 95
PLUS                 : 90 102
PRIVATE              : 16
PUBLIC               : 15
RBRACK               : 5 38
RETURN               : 44
RPAREN               : 28 29 32 41 42 43 66 67 77
SEMICOLON            : 20 43 43 44 45 46 47 50
STATIC               : 18
STRING_CONST         : 59
SUPER                : 65
THIS                 : 64
TIMES                : 92
TRUE                 : 61
VOID                 : 29
WHILE                : 42
error                : 

Nonterminals, with rules where they appear

arguments            : 70 72 78
arith_op             : 82
assign               : 81 105
block                : 28 29 32 48
bool_op              : 83
class_body_decl      : 8 9
class_body_decl_mult : 5 8
class_decl           : 2 3
constructor_decl     : 12
empty                : 4 7 17 19 31 34 40 52 54 56 71 79
expr                 : 41 42 53 66 72 73 82 82 83 83 84 85
field_access         : 74 77
field_decl           : 10
formal_param         : 35 36
formals              : 30 33 35
lhs                  : 68 85 86 87 88 89
literal              : 63
method_decl          : 11
method_invocation    : 69 106
modifier             : 13 28 29 32
opt_args             : 67
opt_args_alt         : 77
opt_else_stmt        : 41
opt_expr             : 43 44
opt_extend           : 5
opt_formals          : 28 29
opt_formals_alt      : 32
opt_static           : 14
opt_stmt_expr        : 43 43
primary              : 75 80
program              : 3 0
stmt                 : 39 41 42 43 51
stmt_expr            : 45 55
stmt_mult            : 38 39
type                 : 20 28 37
unary_op             : 84
var_decl             : 13 49
variable             : 25 26 37
variables            : 20 25
visibility           : 14

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . class_decl
    (3) program -> . class_decl program
    (4) program -> . empty
    (5) class_decl -> . CLASS ID opt_extend LBRACK class_body_decl_mult RBRACK
    (1) empty -> .

    CLASS           shift and go to state 4
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    class_decl                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (2) program -> class_decl .
    (3) program -> class_decl . program
    (2) program -> . class_decl
    (3) program -> . class_decl program
    (4) program -> . empty
    (5) class_decl -> . CLASS ID opt_extend LBRACK class_body_decl_mult RBRACK
    (1) empty -> .

  ! reduce/reduce conflict for $end resolved using rule 1 (empty -> .)
    CLASS           shift and go to state 4
    $end            reduce using rule 1 (empty -> .)

  ! $end            [ reduce using rule 2 (program -> class_decl .) ]

    class_decl                     shift and go to state 2
    program                        shift and go to state 5
    empty                          shift and go to state 3

state 3

    (4) program -> empty .

    $end            reduce using rule 4 (program -> empty .)


state 4

    (5) class_decl -> CLASS . ID opt_extend LBRACK class_body_decl_mult RBRACK

    ID              shift and go to state 6


state 5

    (3) program -> class_decl program .

    $end            reduce using rule 3 (program -> class_decl program .)


state 6

    (5) class_decl -> CLASS ID . opt_extend LBRACK class_body_decl_mult RBRACK
    (6) opt_extend -> . EXTENDS ID
    (7) opt_extend -> . empty
    (1) empty -> .

    EXTENDS         shift and go to state 8
    LBRACK          reduce using rule 1 (empty -> .)

    opt_extend                     shift and go to state 7
    empty                          shift and go to state 9

state 7

    (5) class_decl -> CLASS ID opt_extend . LBRACK class_body_decl_mult RBRACK

    LBRACK          shift and go to state 10


state 8

    (6) opt_extend -> EXTENDS . ID

    ID              shift and go to state 11


state 9

    (7) opt_extend -> empty .

    LBRACK          reduce using rule 7 (opt_extend -> empty .)


state 10

    (5) class_decl -> CLASS ID opt_extend LBRACK . class_body_decl_mult RBRACK
    (8) class_body_decl_mult -> . class_body_decl_mult class_body_decl
    (9) class_body_decl_mult -> . class_body_decl
    (10) class_body_decl -> . field_decl
    (11) class_body_decl -> . method_decl
    (12) class_body_decl -> . constructor_decl
    (13) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type ID LPAREN opt_formals RPAREN block
    (29) method_decl -> . modifier VOID ID LPAREN opt_formals RPAREN block
    (32) constructor_decl -> . modifier ID LPAREN opt_formals_alt RPAREN block
    (14) modifier -> . visibility opt_static
    (15) visibility -> . PUBLIC
    (16) visibility -> . PRIVATE
    (17) visibility -> . empty
    (1) empty -> .

    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          reduce using rule 1 (empty -> .)
    VOID            reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)

    class_body_decl_mult           shift and go to state 12
    class_body_decl                shift and go to state 13
    field_decl                     shift and go to state 14
    method_decl                    shift and go to state 15
    constructor_decl               shift and go to state 16
    modifier                       shift and go to state 17
    visibility                     shift and go to state 18
    empty                          shift and go to state 21

state 11

    (6) opt_extend -> EXTENDS ID .

    LBRACK          reduce using rule 6 (opt_extend -> EXTENDS ID .)


state 12

    (5) class_decl -> CLASS ID opt_extend LBRACK class_body_decl_mult . RBRACK
    (8) class_body_decl_mult -> class_body_decl_mult . class_body_decl
    (10) class_body_decl -> . field_decl
    (11) class_body_decl -> . method_decl
    (12) class_body_decl -> . constructor_decl
    (13) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type ID LPAREN opt_formals RPAREN block
    (29) method_decl -> . modifier VOID ID LPAREN opt_formals RPAREN block
    (32) constructor_decl -> . modifier ID LPAREN opt_formals_alt RPAREN block
    (14) modifier -> . visibility opt_static
    (15) visibility -> . PUBLIC
    (16) visibility -> . PRIVATE
    (17) visibility -> . empty
    (1) empty -> .

    RBRACK          shift and go to state 22
    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          reduce using rule 1 (empty -> .)
    VOID            reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)

    class_body_decl                shift and go to state 23
    field_decl                     shift and go to state 14
    method_decl                    shift and go to state 15
    constructor_decl               shift and go to state 16
    modifier                       shift and go to state 17
    visibility                     shift and go to state 18
    empty                          shift and go to state 21

state 13

    (9) class_body_decl_mult -> class_body_decl .

    RBRACK          reduce using rule 9 (class_body_decl_mult -> class_body_decl .)
    PUBLIC          reduce using rule 9 (class_body_decl_mult -> class_body_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl_mult -> class_body_decl .)
    VOID            reduce using rule 9 (class_body_decl_mult -> class_body_decl .)
    ID              reduce using rule 9 (class_body_decl_mult -> class_body_decl .)
    INT             reduce using rule 9 (class_body_decl_mult -> class_body_decl .)
    FLOAT           reduce using rule 9 (class_body_decl_mult -> class_body_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl_mult -> class_body_decl .)
    STATIC          reduce using rule 9 (class_body_decl_mult -> class_body_decl .)


state 14

    (10) class_body_decl -> field_decl .

    RBRACK          reduce using rule 10 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 10 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 10 (class_body_decl -> field_decl .)
    VOID            reduce using rule 10 (class_body_decl -> field_decl .)
    ID              reduce using rule 10 (class_body_decl -> field_decl .)
    INT             reduce using rule 10 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 10 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 10 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 10 (class_body_decl -> field_decl .)


state 15

    (11) class_body_decl -> method_decl .

    RBRACK          reduce using rule 11 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 11 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl -> method_decl .)
    VOID            reduce using rule 11 (class_body_decl -> method_decl .)
    ID              reduce using rule 11 (class_body_decl -> method_decl .)
    INT             reduce using rule 11 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 11 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 11 (class_body_decl -> method_decl .)


state 16

    (12) class_body_decl -> constructor_decl .

    RBRACK          reduce using rule 12 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 12 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 12 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 12 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 12 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 12 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 12 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 12 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 12 (class_body_decl -> constructor_decl .)


state 17

    (13) field_decl -> modifier . var_decl
    (28) method_decl -> modifier . type ID LPAREN opt_formals RPAREN block
    (29) method_decl -> modifier . VOID ID LPAREN opt_formals RPAREN block
    (32) constructor_decl -> modifier . ID LPAREN opt_formals_alt RPAREN block
    (20) var_decl -> . type variables SEMICOLON
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    VOID            shift and go to state 27
    ID              shift and go to state 26
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30

    var_decl                       shift and go to state 24
    type                           shift and go to state 25

state 18

    (14) modifier -> visibility . opt_static
    (18) opt_static -> . STATIC
    (19) opt_static -> . empty
    (1) empty -> .

    STATIC          shift and go to state 32
    VOID            reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)

    opt_static                     shift and go to state 31
    empty                          shift and go to state 33

state 19

    (15) visibility -> PUBLIC .

    STATIC          reduce using rule 15 (visibility -> PUBLIC .)
    VOID            reduce using rule 15 (visibility -> PUBLIC .)
    ID              reduce using rule 15 (visibility -> PUBLIC .)
    INT             reduce using rule 15 (visibility -> PUBLIC .)
    FLOAT           reduce using rule 15 (visibility -> PUBLIC .)
    BOOLEAN         reduce using rule 15 (visibility -> PUBLIC .)


state 20

    (16) visibility -> PRIVATE .

    STATIC          reduce using rule 16 (visibility -> PRIVATE .)
    VOID            reduce using rule 16 (visibility -> PRIVATE .)
    ID              reduce using rule 16 (visibility -> PRIVATE .)
    INT             reduce using rule 16 (visibility -> PRIVATE .)
    FLOAT           reduce using rule 16 (visibility -> PRIVATE .)
    BOOLEAN         reduce using rule 16 (visibility -> PRIVATE .)


state 21

    (17) visibility -> empty .

    STATIC          reduce using rule 17 (visibility -> empty .)
    VOID            reduce using rule 17 (visibility -> empty .)
    ID              reduce using rule 17 (visibility -> empty .)
    INT             reduce using rule 17 (visibility -> empty .)
    FLOAT           reduce using rule 17 (visibility -> empty .)
    BOOLEAN         reduce using rule 17 (visibility -> empty .)


state 22

    (5) class_decl -> CLASS ID opt_extend LBRACK class_body_decl_mult RBRACK .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID opt_extend LBRACK class_body_decl_mult RBRACK .)
    $end            reduce using rule 5 (class_decl -> CLASS ID opt_extend LBRACK class_body_decl_mult RBRACK .)


state 23

    (8) class_body_decl_mult -> class_body_decl_mult class_body_decl .

    RBRACK          reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)
    PUBLIC          reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)
    PRIVATE         reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)
    VOID            reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)
    ID              reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)
    INT             reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)
    FLOAT           reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)
    BOOLEAN         reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)
    STATIC          reduce using rule 8 (class_body_decl_mult -> class_body_decl_mult class_body_decl .)


state 24

    (13) field_decl -> modifier var_decl .

    RBRACK          reduce using rule 13 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 13 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 13 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 13 (field_decl -> modifier var_decl .)
    ID              reduce using rule 13 (field_decl -> modifier var_decl .)
    INT             reduce using rule 13 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 13 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 13 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 13 (field_decl -> modifier var_decl .)


state 25

    (28) method_decl -> modifier type . ID LPAREN opt_formals RPAREN block
    (20) var_decl -> type . variables SEMICOLON
    (25) variables -> . variables COMMA variable
    (26) variables -> . variable
    (27) variable -> . ID

    ID              shift and go to state 34

    variables                      shift and go to state 35
    variable                       shift and go to state 36

state 26

    (32) constructor_decl -> modifier ID . LPAREN opt_formals_alt RPAREN block
    (24) type -> ID .

    LPAREN          shift and go to state 37
    ID              reduce using rule 24 (type -> ID .)


state 27

    (29) method_decl -> modifier VOID . ID LPAREN opt_formals RPAREN block

    ID              shift and go to state 38


state 28

    (21) type -> INT .

    ID              reduce using rule 21 (type -> INT .)


state 29

    (22) type -> FLOAT .

    ID              reduce using rule 22 (type -> FLOAT .)


state 30

    (23) type -> BOOLEAN .

    ID              reduce using rule 23 (type -> BOOLEAN .)


state 31

    (14) modifier -> visibility opt_static .

    VOID            reduce using rule 14 (modifier -> visibility opt_static .)
    ID              reduce using rule 14 (modifier -> visibility opt_static .)
    INT             reduce using rule 14 (modifier -> visibility opt_static .)
    FLOAT           reduce using rule 14 (modifier -> visibility opt_static .)
    BOOLEAN         reduce using rule 14 (modifier -> visibility opt_static .)


state 32

    (18) opt_static -> STATIC .

    VOID            reduce using rule 18 (opt_static -> STATIC .)
    ID              reduce using rule 18 (opt_static -> STATIC .)
    INT             reduce using rule 18 (opt_static -> STATIC .)
    FLOAT           reduce using rule 18 (opt_static -> STATIC .)
    BOOLEAN         reduce using rule 18 (opt_static -> STATIC .)


state 33

    (19) opt_static -> empty .

    VOID            reduce using rule 19 (opt_static -> empty .)
    ID              reduce using rule 19 (opt_static -> empty .)
    INT             reduce using rule 19 (opt_static -> empty .)
    FLOAT           reduce using rule 19 (opt_static -> empty .)
    BOOLEAN         reduce using rule 19 (opt_static -> empty .)


state 34

    (28) method_decl -> modifier type ID . LPAREN opt_formals RPAREN block
    (27) variable -> ID .

    LPAREN          shift and go to state 39
    SEMICOLON       reduce using rule 27 (variable -> ID .)
    COMMA           reduce using rule 27 (variable -> ID .)


state 35

    (20) var_decl -> type variables . SEMICOLON
    (25) variables -> variables . COMMA variable

    SEMICOLON       shift and go to state 40
    COMMA           shift and go to state 41


state 36

    (26) variables -> variable .

    SEMICOLON       reduce using rule 26 (variables -> variable .)
    COMMA           reduce using rule 26 (variables -> variable .)


state 37

    (32) constructor_decl -> modifier ID LPAREN . opt_formals_alt RPAREN block
    (33) opt_formals_alt -> . formals
    (34) opt_formals_alt -> . empty
    (35) formals -> . formals COMMA formal_param
    (36) formals -> . formal_param
    (1) empty -> .
    (37) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    RPAREN          reduce using rule 1 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 42

    opt_formals_alt                shift and go to state 43
    formals                        shift and go to state 44
    empty                          shift and go to state 45
    formal_param                   shift and go to state 46
    type                           shift and go to state 47

state 38

    (29) method_decl -> modifier VOID ID . LPAREN opt_formals RPAREN block

    LPAREN          shift and go to state 48


state 39

    (28) method_decl -> modifier type ID LPAREN . opt_formals RPAREN block
    (30) opt_formals -> . formals
    (31) opt_formals -> . empty
    (35) formals -> . formals COMMA formal_param
    (36) formals -> . formal_param
    (1) empty -> .
    (37) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    RPAREN          reduce using rule 1 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 42

    type                           shift and go to state 47
    opt_formals                    shift and go to state 49
    formals                        shift and go to state 50
    empty                          shift and go to state 51
    formal_param                   shift and go to state 46

state 40

    (20) var_decl -> type variables SEMICOLON .

    RBRACK          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    LBRACK          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    DOUBLE_PLUS     reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    DOUBLE_MINUS    reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    INT_CONST       reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FLOAT_CONST     reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    STRING_CONST    reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 20 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 20 (var_decl -> type variables SEMICOLON .)


state 41

    (25) variables -> variables COMMA . variable
    (27) variable -> . ID

    ID              shift and go to state 53

    variable                       shift and go to state 52

state 42

    (24) type -> ID .

    ID              reduce using rule 24 (type -> ID .)


state 43

    (32) constructor_decl -> modifier ID LPAREN opt_formals_alt . RPAREN block

    RPAREN          shift and go to state 54


state 44

    (33) opt_formals_alt -> formals .
    (35) formals -> formals . COMMA formal_param

    RPAREN          reduce using rule 33 (opt_formals_alt -> formals .)
    COMMA           shift and go to state 55


state 45

    (34) opt_formals_alt -> empty .

    RPAREN          reduce using rule 34 (opt_formals_alt -> empty .)


state 46

    (36) formals -> formal_param .

    COMMA           reduce using rule 36 (formals -> formal_param .)
    RPAREN          reduce using rule 36 (formals -> formal_param .)


state 47

    (37) formal_param -> type . variable
    (27) variable -> . ID

    ID              shift and go to state 53

    variable                       shift and go to state 56

state 48

    (29) method_decl -> modifier VOID ID LPAREN . opt_formals RPAREN block
    (30) opt_formals -> . formals
    (31) opt_formals -> . empty
    (35) formals -> . formals COMMA formal_param
    (36) formals -> . formal_param
    (1) empty -> .
    (37) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    RPAREN          reduce using rule 1 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 42

    opt_formals                    shift and go to state 57
    formals                        shift and go to state 50
    empty                          shift and go to state 51
    formal_param                   shift and go to state 46
    type                           shift and go to state 47

state 49

    (28) method_decl -> modifier type ID LPAREN opt_formals . RPAREN block

    RPAREN          shift and go to state 58


state 50

    (30) opt_formals -> formals .
    (35) formals -> formals . COMMA formal_param

    RPAREN          reduce using rule 30 (opt_formals -> formals .)
    COMMA           shift and go to state 55


state 51

    (31) opt_formals -> empty .

    RPAREN          reduce using rule 31 (opt_formals -> empty .)


state 52

    (25) variables -> variables COMMA variable .

    SEMICOLON       reduce using rule 25 (variables -> variables COMMA variable .)
    COMMA           reduce using rule 25 (variables -> variables COMMA variable .)


state 53

    (27) variable -> ID .

    SEMICOLON       reduce using rule 27 (variable -> ID .)
    COMMA           reduce using rule 27 (variable -> ID .)
    RPAREN          reduce using rule 27 (variable -> ID .)


state 54

    (32) constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN . block
    (38) block -> . LBRACK stmt_mult RBRACK

    LBRACK          shift and go to state 60

    block                          shift and go to state 59

state 55

    (35) formals -> formals COMMA . formal_param
    (37) formal_param -> . type variable
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 42

    formal_param                   shift and go to state 61
    type                           shift and go to state 47

state 56

    (37) formal_param -> type variable .

    COMMA           reduce using rule 37 (formal_param -> type variable .)
    RPAREN          reduce using rule 37 (formal_param -> type variable .)


state 57

    (29) method_decl -> modifier VOID ID LPAREN opt_formals . RPAREN block

    RPAREN          shift and go to state 62


state 58

    (28) method_decl -> modifier type ID LPAREN opt_formals RPAREN . block
    (38) block -> . LBRACK stmt_mult RBRACK

    LBRACK          shift and go to state 60

    block                          shift and go to state 63

state 59

    (32) constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .

    RBRACK          reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)
    PUBLIC          reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)
    PRIVATE         reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)
    VOID            reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)
    ID              reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)
    INT             reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)
    FLOAT           reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)
    BOOLEAN         reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)
    STATIC          reduce using rule 32 (constructor_decl -> modifier ID LPAREN opt_formals_alt RPAREN block .)


state 60

    (38) block -> LBRACK . stmt_mult RBRACK
    (39) stmt_mult -> . stmt_mult stmt
    (40) stmt_mult -> . empty
    (1) empty -> .

    RBRACK          reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    CONTINUE        reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    LBRACK          reduce using rule 1 (empty -> .)
    DOUBLE_PLUS     reduce using rule 1 (empty -> .)
    DOUBLE_MINUS    reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    THIS            reduce using rule 1 (empty -> .)
    SUPER           reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    NEW             reduce using rule 1 (empty -> .)
    INT_CONST       reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    STRING_CONST    reduce using rule 1 (empty -> .)
    NULL            reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)

    stmt_mult                      shift and go to state 64
    empty                          shift and go to state 65

state 61

    (35) formals -> formals COMMA formal_param .

    COMMA           reduce using rule 35 (formals -> formals COMMA formal_param .)
    RPAREN          reduce using rule 35 (formals -> formals COMMA formal_param .)


state 62

    (29) method_decl -> modifier VOID ID LPAREN opt_formals RPAREN . block
    (38) block -> . LBRACK stmt_mult RBRACK

    LBRACK          shift and go to state 60

    block                          shift and go to state 66

state 63

    (28) method_decl -> modifier type ID LPAREN opt_formals RPAREN block .

    RBRACK          reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)
    PUBLIC          reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)
    PRIVATE         reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)
    VOID            reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)
    ID              reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)
    INT             reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)
    FLOAT           reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)
    BOOLEAN         reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)
    STATIC          reduce using rule 28 (method_decl -> modifier type ID LPAREN opt_formals RPAREN block .)


state 64

    (38) block -> LBRACK stmt_mult . RBRACK
    (39) stmt_mult -> stmt_mult . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt opt_else_stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt
    (44) stmt -> . RETURN opt_expr SEMICOLON
    (45) stmt -> . stmt_expr SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (38) block -> . LBRACK stmt_mult RBRACK
    (20) var_decl -> . type variables SEMICOLON
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    RBRACK          shift and go to state 67
    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 74
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 73
    LBRACK          shift and go to state 60
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt                           shift and go to state 68
    stmt_expr                      shift and go to state 75
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 65

    (40) stmt_mult -> empty .

    RBRACK          reduce using rule 40 (stmt_mult -> empty .)
    IF              reduce using rule 40 (stmt_mult -> empty .)
    WHILE           reduce using rule 40 (stmt_mult -> empty .)
    FOR             reduce using rule 40 (stmt_mult -> empty .)
    RETURN          reduce using rule 40 (stmt_mult -> empty .)
    BREAK           reduce using rule 40 (stmt_mult -> empty .)
    CONTINUE        reduce using rule 40 (stmt_mult -> empty .)
    SEMICOLON       reduce using rule 40 (stmt_mult -> empty .)
    LBRACK          reduce using rule 40 (stmt_mult -> empty .)
    DOUBLE_PLUS     reduce using rule 40 (stmt_mult -> empty .)
    DOUBLE_MINUS    reduce using rule 40 (stmt_mult -> empty .)
    INT             reduce using rule 40 (stmt_mult -> empty .)
    FLOAT           reduce using rule 40 (stmt_mult -> empty .)
    BOOLEAN         reduce using rule 40 (stmt_mult -> empty .)
    ID              reduce using rule 40 (stmt_mult -> empty .)
    THIS            reduce using rule 40 (stmt_mult -> empty .)
    SUPER           reduce using rule 40 (stmt_mult -> empty .)
    LPAREN          reduce using rule 40 (stmt_mult -> empty .)
    NEW             reduce using rule 40 (stmt_mult -> empty .)
    INT_CONST       reduce using rule 40 (stmt_mult -> empty .)
    FLOAT_CONST     reduce using rule 40 (stmt_mult -> empty .)
    STRING_CONST    reduce using rule 40 (stmt_mult -> empty .)
    NULL            reduce using rule 40 (stmt_mult -> empty .)
    TRUE            reduce using rule 40 (stmt_mult -> empty .)
    FALSE           reduce using rule 40 (stmt_mult -> empty .)


state 66

    (29) method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .

    RBRACK          reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)
    PUBLIC          reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)
    PRIVATE         reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)
    VOID            reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)
    ID              reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)
    INT             reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)
    FLOAT           reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)
    BOOLEAN         reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)
    STATIC          reduce using rule 29 (method_decl -> modifier VOID ID LPAREN opt_formals RPAREN block .)


state 67

    (38) block -> LBRACK stmt_mult RBRACK .

    RBRACK          reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    PUBLIC          reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    PRIVATE         reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    VOID            reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    ID              reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    INT             reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    FLOAT           reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    BOOLEAN         reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    STATIC          reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    IF              reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    WHILE           reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    FOR             reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    RETURN          reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    BREAK           reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    CONTINUE        reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    SEMICOLON       reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    LBRACK          reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    DOUBLE_PLUS     reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    DOUBLE_MINUS    reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    THIS            reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    SUPER           reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    LPAREN          reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    NEW             reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    INT_CONST       reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    FLOAT_CONST     reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    STRING_CONST    reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    NULL            reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    TRUE            reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    FALSE           reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)
    ELSE            reduce using rule 38 (block -> LBRACK stmt_mult RBRACK .)


state 68

    (39) stmt_mult -> stmt_mult stmt .

    RBRACK          reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    IF              reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    WHILE           reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    FOR             reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    RETURN          reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    BREAK           reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    CONTINUE        reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    SEMICOLON       reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    LBRACK          reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    DOUBLE_PLUS     reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    DOUBLE_MINUS    reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    INT             reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    FLOAT           reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    BOOLEAN         reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    ID              reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    THIS            reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    SUPER           reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    LPAREN          reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    NEW             reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    INT_CONST       reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    FLOAT_CONST     reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    STRING_CONST    reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    NULL            reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    TRUE            reduce using rule 39 (stmt_mult -> stmt_mult stmt .)
    FALSE           reduce using rule 39 (stmt_mult -> stmt_mult stmt .)


state 69

    (41) stmt -> IF . LPAREN expr RPAREN stmt opt_else_stmt

    LPAREN          shift and go to state 99


state 70

    (66) primary -> LPAREN . expr RPAREN
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    expr                           shift and go to state 100
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 71

    (42) stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 111


state 72

    (43) stmt -> FOR . LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt

    LPAREN          shift and go to state 112


state 73

    (50) stmt -> SEMICOLON .

    RBRACK          reduce using rule 50 (stmt -> SEMICOLON .)
    IF              reduce using rule 50 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 50 (stmt -> SEMICOLON .)
    FOR             reduce using rule 50 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 50 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 50 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 50 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stmt -> SEMICOLON .)
    LBRACK          reduce using rule 50 (stmt -> SEMICOLON .)
    DOUBLE_PLUS     reduce using rule 50 (stmt -> SEMICOLON .)
    DOUBLE_MINUS    reduce using rule 50 (stmt -> SEMICOLON .)
    INT             reduce using rule 50 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 50 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 50 (stmt -> SEMICOLON .)
    ID              reduce using rule 50 (stmt -> SEMICOLON .)
    THIS            reduce using rule 50 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 50 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 50 (stmt -> SEMICOLON .)
    NEW             reduce using rule 50 (stmt -> SEMICOLON .)
    INT_CONST       reduce using rule 50 (stmt -> SEMICOLON .)
    FLOAT_CONST     reduce using rule 50 (stmt -> SEMICOLON .)
    STRING_CONST    reduce using rule 50 (stmt -> SEMICOLON .)
    NULL            reduce using rule 50 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 50 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 50 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 50 (stmt -> SEMICOLON .)


state 74

    (44) stmt -> RETURN . opt_expr SEMICOLON
    (53) opt_expr -> . expr
    (54) opt_expr -> . empty
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (1) empty -> .
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    SEMICOLON       reduce using rule 1 (empty -> .)
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    opt_expr                       shift and go to state 113
    expr                           shift and go to state 114
    empty                          shift and go to state 115
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 75

    (45) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 116


state 76

    (46) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 117


state 77

    (47) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 118


state 78

    (48) stmt -> block .

    RBRACK          reduce using rule 48 (stmt -> block .)
    IF              reduce using rule 48 (stmt -> block .)
    WHILE           reduce using rule 48 (stmt -> block .)
    FOR             reduce using rule 48 (stmt -> block .)
    RETURN          reduce using rule 48 (stmt -> block .)
    BREAK           reduce using rule 48 (stmt -> block .)
    CONTINUE        reduce using rule 48 (stmt -> block .)
    SEMICOLON       reduce using rule 48 (stmt -> block .)
    LBRACK          reduce using rule 48 (stmt -> block .)
    DOUBLE_PLUS     reduce using rule 48 (stmt -> block .)
    DOUBLE_MINUS    reduce using rule 48 (stmt -> block .)
    INT             reduce using rule 48 (stmt -> block .)
    FLOAT           reduce using rule 48 (stmt -> block .)
    BOOLEAN         reduce using rule 48 (stmt -> block .)
    ID              reduce using rule 48 (stmt -> block .)
    THIS            reduce using rule 48 (stmt -> block .)
    SUPER           reduce using rule 48 (stmt -> block .)
    LPAREN          reduce using rule 48 (stmt -> block .)
    NEW             reduce using rule 48 (stmt -> block .)
    INT_CONST       reduce using rule 48 (stmt -> block .)
    FLOAT_CONST     reduce using rule 48 (stmt -> block .)
    STRING_CONST    reduce using rule 48 (stmt -> block .)
    NULL            reduce using rule 48 (stmt -> block .)
    TRUE            reduce using rule 48 (stmt -> block .)
    FALSE           reduce using rule 48 (stmt -> block .)
    ELSE            reduce using rule 48 (stmt -> block .)


state 79

    (49) stmt -> var_decl .

    RBRACK          reduce using rule 49 (stmt -> var_decl .)
    IF              reduce using rule 49 (stmt -> var_decl .)
    WHILE           reduce using rule 49 (stmt -> var_decl .)
    FOR             reduce using rule 49 (stmt -> var_decl .)
    RETURN          reduce using rule 49 (stmt -> var_decl .)
    BREAK           reduce using rule 49 (stmt -> var_decl .)
    CONTINUE        reduce using rule 49 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 49 (stmt -> var_decl .)
    LBRACK          reduce using rule 49 (stmt -> var_decl .)
    DOUBLE_PLUS     reduce using rule 49 (stmt -> var_decl .)
    DOUBLE_MINUS    reduce using rule 49 (stmt -> var_decl .)
    INT             reduce using rule 49 (stmt -> var_decl .)
    FLOAT           reduce using rule 49 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 49 (stmt -> var_decl .)
    ID              reduce using rule 49 (stmt -> var_decl .)
    THIS            reduce using rule 49 (stmt -> var_decl .)
    SUPER           reduce using rule 49 (stmt -> var_decl .)
    LPAREN          reduce using rule 49 (stmt -> var_decl .)
    NEW             reduce using rule 49 (stmt -> var_decl .)
    INT_CONST       reduce using rule 49 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 49 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 49 (stmt -> var_decl .)
    NULL            reduce using rule 49 (stmt -> var_decl .)
    TRUE            reduce using rule 49 (stmt -> var_decl .)
    FALSE           reduce using rule 49 (stmt -> var_decl .)
    ELSE            reduce using rule 49 (stmt -> var_decl .)


state 80

    (105) stmt_expr -> assign .

    SEMICOLON       reduce using rule 105 (stmt_expr -> assign .)
    RPAREN          reduce using rule 105 (stmt_expr -> assign .)


state 81

    (106) stmt_expr -> method_invocation .
    (69) primary -> method_invocation .

    SEMICOLON       reduce using rule 106 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 106 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 69 (primary -> method_invocation .)


state 82

    (20) var_decl -> type . variables SEMICOLON
    (25) variables -> . variables COMMA variable
    (26) variables -> . variable
    (27) variable -> . ID

    ID              shift and go to state 53

    variables                      shift and go to state 35
    variable                       shift and go to state 36

state 83

    (85) assign -> lhs . EQUALS expr
    (86) assign -> lhs . DOUBLE_PLUS
    (88) assign -> lhs . DOUBLE_MINUS
    (68) primary -> lhs .

    EQUALS          shift and go to state 119
    DOUBLE_PLUS     shift and go to state 120
    DOUBLE_MINUS    shift and go to state 121
    DOT             reduce using rule 68 (primary -> lhs .)


state 84

    (87) assign -> DOUBLE_PLUS . lhs
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN

    ID              shift and go to state 104
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    lhs                            shift and go to state 122
    field_access                   shift and go to state 110
    primary                        shift and go to state 88
    literal                        shift and go to state 89
    method_invocation              shift and go to state 106

state 85

    (89) assign -> DOUBLE_MINUS . lhs
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN

    ID              shift and go to state 104
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    lhs                            shift and go to state 123
    field_access                   shift and go to state 110
    primary                        shift and go to state 88
    literal                        shift and go to state 89
    method_invocation              shift and go to state 106

state 86

    (77) method_invocation -> field_access . LPAREN opt_args_alt RPAREN
    (74) lhs -> field_access .

    LPAREN          shift and go to state 124
    EQUALS          reduce using rule 74 (lhs -> field_access .)
    DOUBLE_PLUS     reduce using rule 74 (lhs -> field_access .)
    DOUBLE_MINUS    reduce using rule 74 (lhs -> field_access .)
    DOT             reduce using rule 74 (lhs -> field_access .)


state 87

    (24) type -> ID .
    (76) field_access -> ID .

    ID              reduce using rule 24 (type -> ID .)
    LPAREN          reduce using rule 76 (field_access -> ID .)
    EQUALS          reduce using rule 76 (field_access -> ID .)
    DOUBLE_PLUS     reduce using rule 76 (field_access -> ID .)
    DOUBLE_MINUS    reduce using rule 76 (field_access -> ID .)
    DOT             reduce using rule 76 (field_access -> ID .)


state 88

    (75) field_access -> primary . DOT ID

    DOT             shift and go to state 125


state 89

    (63) primary -> literal .

    DOT             reduce using rule 63 (primary -> literal .)
    RPAREN          reduce using rule 63 (primary -> literal .)
    PLUS            reduce using rule 63 (primary -> literal .)
    MINUS           reduce using rule 63 (primary -> literal .)
    TIMES           reduce using rule 63 (primary -> literal .)
    DIVIDE          reduce using rule 63 (primary -> literal .)
    AND             reduce using rule 63 (primary -> literal .)
    OR              reduce using rule 63 (primary -> literal .)
    DOUBLE_EQUALS   reduce using rule 63 (primary -> literal .)
    NOT_EQUAL       reduce using rule 63 (primary -> literal .)
    L_EQ            reduce using rule 63 (primary -> literal .)
    G_EQ            reduce using rule 63 (primary -> literal .)
    LESS            reduce using rule 63 (primary -> literal .)
    GREATER         reduce using rule 63 (primary -> literal .)
    SEMICOLON       reduce using rule 63 (primary -> literal .)
    COMMA           reduce using rule 63 (primary -> literal .)


state 90

    (64) primary -> THIS .

    DOT             reduce using rule 64 (primary -> THIS .)
    RPAREN          reduce using rule 64 (primary -> THIS .)
    PLUS            reduce using rule 64 (primary -> THIS .)
    MINUS           reduce using rule 64 (primary -> THIS .)
    TIMES           reduce using rule 64 (primary -> THIS .)
    DIVIDE          reduce using rule 64 (primary -> THIS .)
    AND             reduce using rule 64 (primary -> THIS .)
    OR              reduce using rule 64 (primary -> THIS .)
    DOUBLE_EQUALS   reduce using rule 64 (primary -> THIS .)
    NOT_EQUAL       reduce using rule 64 (primary -> THIS .)
    L_EQ            reduce using rule 64 (primary -> THIS .)
    G_EQ            reduce using rule 64 (primary -> THIS .)
    LESS            reduce using rule 64 (primary -> THIS .)
    GREATER         reduce using rule 64 (primary -> THIS .)
    SEMICOLON       reduce using rule 64 (primary -> THIS .)
    COMMA           reduce using rule 64 (primary -> THIS .)


state 91

    (65) primary -> SUPER .

    DOT             reduce using rule 65 (primary -> SUPER .)
    RPAREN          reduce using rule 65 (primary -> SUPER .)
    PLUS            reduce using rule 65 (primary -> SUPER .)
    MINUS           reduce using rule 65 (primary -> SUPER .)
    TIMES           reduce using rule 65 (primary -> SUPER .)
    DIVIDE          reduce using rule 65 (primary -> SUPER .)
    AND             reduce using rule 65 (primary -> SUPER .)
    OR              reduce using rule 65 (primary -> SUPER .)
    DOUBLE_EQUALS   reduce using rule 65 (primary -> SUPER .)
    NOT_EQUAL       reduce using rule 65 (primary -> SUPER .)
    L_EQ            reduce using rule 65 (primary -> SUPER .)
    G_EQ            reduce using rule 65 (primary -> SUPER .)
    LESS            reduce using rule 65 (primary -> SUPER .)
    GREATER         reduce using rule 65 (primary -> SUPER .)
    SEMICOLON       reduce using rule 65 (primary -> SUPER .)
    COMMA           reduce using rule 65 (primary -> SUPER .)


state 92

    (67) primary -> NEW . ID LPAREN opt_args RPAREN

    ID              shift and go to state 126


state 93

    (57) literal -> INT_CONST .

    DOT             reduce using rule 57 (literal -> INT_CONST .)
    RPAREN          reduce using rule 57 (literal -> INT_CONST .)
    PLUS            reduce using rule 57 (literal -> INT_CONST .)
    MINUS           reduce using rule 57 (literal -> INT_CONST .)
    TIMES           reduce using rule 57 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 57 (literal -> INT_CONST .)
    AND             reduce using rule 57 (literal -> INT_CONST .)
    OR              reduce using rule 57 (literal -> INT_CONST .)
    DOUBLE_EQUALS   reduce using rule 57 (literal -> INT_CONST .)
    NOT_EQUAL       reduce using rule 57 (literal -> INT_CONST .)
    L_EQ            reduce using rule 57 (literal -> INT_CONST .)
    G_EQ            reduce using rule 57 (literal -> INT_CONST .)
    LESS            reduce using rule 57 (literal -> INT_CONST .)
    GREATER         reduce using rule 57 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 57 (literal -> INT_CONST .)
    COMMA           reduce using rule 57 (literal -> INT_CONST .)


state 94

    (58) literal -> FLOAT_CONST .

    DOT             reduce using rule 58 (literal -> FLOAT_CONST .)
    RPAREN          reduce using rule 58 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 58 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 58 (literal -> FLOAT_CONST .)
    TIMES           reduce using rule 58 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 58 (literal -> FLOAT_CONST .)
    AND             reduce using rule 58 (literal -> FLOAT_CONST .)
    OR              reduce using rule 58 (literal -> FLOAT_CONST .)
    DOUBLE_EQUALS   reduce using rule 58 (literal -> FLOAT_CONST .)
    NOT_EQUAL       reduce using rule 58 (literal -> FLOAT_CONST .)
    L_EQ            reduce using rule 58 (literal -> FLOAT_CONST .)
    G_EQ            reduce using rule 58 (literal -> FLOAT_CONST .)
    LESS            reduce using rule 58 (literal -> FLOAT_CONST .)
    GREATER         reduce using rule 58 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 58 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 58 (literal -> FLOAT_CONST .)


state 95

    (59) literal -> STRING_CONST .

    DOT             reduce using rule 59 (literal -> STRING_CONST .)
    RPAREN          reduce using rule 59 (literal -> STRING_CONST .)
    PLUS            reduce using rule 59 (literal -> STRING_CONST .)
    MINUS           reduce using rule 59 (literal -> STRING_CONST .)
    TIMES           reduce using rule 59 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 59 (literal -> STRING_CONST .)
    AND             reduce using rule 59 (literal -> STRING_CONST .)
    OR              reduce using rule 59 (literal -> STRING_CONST .)
    DOUBLE_EQUALS   reduce using rule 59 (literal -> STRING_CONST .)
    NOT_EQUAL       reduce using rule 59 (literal -> STRING_CONST .)
    L_EQ            reduce using rule 59 (literal -> STRING_CONST .)
    G_EQ            reduce using rule 59 (literal -> STRING_CONST .)
    LESS            reduce using rule 59 (literal -> STRING_CONST .)
    GREATER         reduce using rule 59 (literal -> STRING_CONST .)
    SEMICOLON       reduce using rule 59 (literal -> STRING_CONST .)
    COMMA           reduce using rule 59 (literal -> STRING_CONST .)


state 96

    (60) literal -> NULL .

    DOT             reduce using rule 60 (literal -> NULL .)
    RPAREN          reduce using rule 60 (literal -> NULL .)
    PLUS            reduce using rule 60 (literal -> NULL .)
    MINUS           reduce using rule 60 (literal -> NULL .)
    TIMES           reduce using rule 60 (literal -> NULL .)
    DIVIDE          reduce using rule 60 (literal -> NULL .)
    AND             reduce using rule 60 (literal -> NULL .)
    OR              reduce using rule 60 (literal -> NULL .)
    DOUBLE_EQUALS   reduce using rule 60 (literal -> NULL .)
    NOT_EQUAL       reduce using rule 60 (literal -> NULL .)
    L_EQ            reduce using rule 60 (literal -> NULL .)
    G_EQ            reduce using rule 60 (literal -> NULL .)
    LESS            reduce using rule 60 (literal -> NULL .)
    GREATER         reduce using rule 60 (literal -> NULL .)
    SEMICOLON       reduce using rule 60 (literal -> NULL .)
    COMMA           reduce using rule 60 (literal -> NULL .)


state 97

    (61) literal -> TRUE .

    DOT             reduce using rule 61 (literal -> TRUE .)
    RPAREN          reduce using rule 61 (literal -> TRUE .)
    PLUS            reduce using rule 61 (literal -> TRUE .)
    MINUS           reduce using rule 61 (literal -> TRUE .)
    TIMES           reduce using rule 61 (literal -> TRUE .)
    DIVIDE          reduce using rule 61 (literal -> TRUE .)
    AND             reduce using rule 61 (literal -> TRUE .)
    OR              reduce using rule 61 (literal -> TRUE .)
    DOUBLE_EQUALS   reduce using rule 61 (literal -> TRUE .)
    NOT_EQUAL       reduce using rule 61 (literal -> TRUE .)
    L_EQ            reduce using rule 61 (literal -> TRUE .)
    G_EQ            reduce using rule 61 (literal -> TRUE .)
    LESS            reduce using rule 61 (literal -> TRUE .)
    GREATER         reduce using rule 61 (literal -> TRUE .)
    SEMICOLON       reduce using rule 61 (literal -> TRUE .)
    COMMA           reduce using rule 61 (literal -> TRUE .)


state 98

    (62) literal -> FALSE .

    DOT             reduce using rule 62 (literal -> FALSE .)
    RPAREN          reduce using rule 62 (literal -> FALSE .)
    PLUS            reduce using rule 62 (literal -> FALSE .)
    MINUS           reduce using rule 62 (literal -> FALSE .)
    TIMES           reduce using rule 62 (literal -> FALSE .)
    DIVIDE          reduce using rule 62 (literal -> FALSE .)
    AND             reduce using rule 62 (literal -> FALSE .)
    OR              reduce using rule 62 (literal -> FALSE .)
    DOUBLE_EQUALS   reduce using rule 62 (literal -> FALSE .)
    NOT_EQUAL       reduce using rule 62 (literal -> FALSE .)
    L_EQ            reduce using rule 62 (literal -> FALSE .)
    G_EQ            reduce using rule 62 (literal -> FALSE .)
    LESS            reduce using rule 62 (literal -> FALSE .)
    GREATER         reduce using rule 62 (literal -> FALSE .)
    SEMICOLON       reduce using rule 62 (literal -> FALSE .)
    COMMA           reduce using rule 62 (literal -> FALSE .)


state 99

    (41) stmt -> IF LPAREN . expr RPAREN stmt opt_else_stmt
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    expr                           shift and go to state 127
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 100

    (66) primary -> LPAREN expr . RPAREN
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

    RPAREN          shift and go to state 128
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 101

    (80) expr -> primary .
    (75) field_access -> primary . DOT ID

    RPAREN          reduce using rule 80 (expr -> primary .)
    PLUS            reduce using rule 80 (expr -> primary .)
    MINUS           reduce using rule 80 (expr -> primary .)
    TIMES           reduce using rule 80 (expr -> primary .)
    DIVIDE          reduce using rule 80 (expr -> primary .)
    AND             reduce using rule 80 (expr -> primary .)
    OR              reduce using rule 80 (expr -> primary .)
    DOUBLE_EQUALS   reduce using rule 80 (expr -> primary .)
    NOT_EQUAL       reduce using rule 80 (expr -> primary .)
    L_EQ            reduce using rule 80 (expr -> primary .)
    G_EQ            reduce using rule 80 (expr -> primary .)
    LESS            reduce using rule 80 (expr -> primary .)
    GREATER         reduce using rule 80 (expr -> primary .)
    SEMICOLON       reduce using rule 80 (expr -> primary .)
    COMMA           reduce using rule 80 (expr -> primary .)
    DOT             shift and go to state 125


state 102

    (81) expr -> assign .

    RPAREN          reduce using rule 81 (expr -> assign .)
    PLUS            reduce using rule 81 (expr -> assign .)
    MINUS           reduce using rule 81 (expr -> assign .)
    TIMES           reduce using rule 81 (expr -> assign .)
    DIVIDE          reduce using rule 81 (expr -> assign .)
    AND             reduce using rule 81 (expr -> assign .)
    OR              reduce using rule 81 (expr -> assign .)
    DOUBLE_EQUALS   reduce using rule 81 (expr -> assign .)
    NOT_EQUAL       reduce using rule 81 (expr -> assign .)
    L_EQ            reduce using rule 81 (expr -> assign .)
    G_EQ            reduce using rule 81 (expr -> assign .)
    LESS            reduce using rule 81 (expr -> assign .)
    GREATER         reduce using rule 81 (expr -> assign .)
    SEMICOLON       reduce using rule 81 (expr -> assign .)
    COMMA           reduce using rule 81 (expr -> assign .)


state 103

    (84) expr -> unary_op . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    unary_op                       shift and go to state 103
    expr                           shift and go to state 143
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 104

    (76) field_access -> ID .

    LPAREN          reduce using rule 76 (field_access -> ID .)
    EQUALS          reduce using rule 76 (field_access -> ID .)
    DOUBLE_PLUS     reduce using rule 76 (field_access -> ID .)
    DOUBLE_MINUS    reduce using rule 76 (field_access -> ID .)
    DOT             reduce using rule 76 (field_access -> ID .)
    RPAREN          reduce using rule 76 (field_access -> ID .)
    PLUS            reduce using rule 76 (field_access -> ID .)
    MINUS           reduce using rule 76 (field_access -> ID .)
    TIMES           reduce using rule 76 (field_access -> ID .)
    DIVIDE          reduce using rule 76 (field_access -> ID .)
    AND             reduce using rule 76 (field_access -> ID .)
    OR              reduce using rule 76 (field_access -> ID .)
    DOUBLE_EQUALS   reduce using rule 76 (field_access -> ID .)
    NOT_EQUAL       reduce using rule 76 (field_access -> ID .)
    L_EQ            reduce using rule 76 (field_access -> ID .)
    G_EQ            reduce using rule 76 (field_access -> ID .)
    LESS            reduce using rule 76 (field_access -> ID .)
    GREATER         reduce using rule 76 (field_access -> ID .)
    SEMICOLON       reduce using rule 76 (field_access -> ID .)
    COMMA           reduce using rule 76 (field_access -> ID .)


state 105

    (68) primary -> lhs .
    (85) assign -> lhs . EQUALS expr
    (86) assign -> lhs . DOUBLE_PLUS
    (88) assign -> lhs . DOUBLE_MINUS

    DOT             reduce using rule 68 (primary -> lhs .)
    RPAREN          reduce using rule 68 (primary -> lhs .)
    PLUS            reduce using rule 68 (primary -> lhs .)
    MINUS           reduce using rule 68 (primary -> lhs .)
    TIMES           reduce using rule 68 (primary -> lhs .)
    DIVIDE          reduce using rule 68 (primary -> lhs .)
    AND             reduce using rule 68 (primary -> lhs .)
    OR              reduce using rule 68 (primary -> lhs .)
    DOUBLE_EQUALS   reduce using rule 68 (primary -> lhs .)
    NOT_EQUAL       reduce using rule 68 (primary -> lhs .)
    L_EQ            reduce using rule 68 (primary -> lhs .)
    G_EQ            reduce using rule 68 (primary -> lhs .)
    LESS            reduce using rule 68 (primary -> lhs .)
    GREATER         reduce using rule 68 (primary -> lhs .)
    SEMICOLON       reduce using rule 68 (primary -> lhs .)
    COMMA           reduce using rule 68 (primary -> lhs .)
    EQUALS          shift and go to state 119
    DOUBLE_PLUS     shift and go to state 120
    DOUBLE_MINUS    shift and go to state 121


state 106

    (69) primary -> method_invocation .

    DOT             reduce using rule 69 (primary -> method_invocation .)
    RPAREN          reduce using rule 69 (primary -> method_invocation .)
    PLUS            reduce using rule 69 (primary -> method_invocation .)
    MINUS           reduce using rule 69 (primary -> method_invocation .)
    TIMES           reduce using rule 69 (primary -> method_invocation .)
    DIVIDE          reduce using rule 69 (primary -> method_invocation .)
    AND             reduce using rule 69 (primary -> method_invocation .)
    OR              reduce using rule 69 (primary -> method_invocation .)
    DOUBLE_EQUALS   reduce using rule 69 (primary -> method_invocation .)
    NOT_EQUAL       reduce using rule 69 (primary -> method_invocation .)
    L_EQ            reduce using rule 69 (primary -> method_invocation .)
    G_EQ            reduce using rule 69 (primary -> method_invocation .)
    LESS            reduce using rule 69 (primary -> method_invocation .)
    GREATER         reduce using rule 69 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 69 (primary -> method_invocation .)
    COMMA           reduce using rule 69 (primary -> method_invocation .)


state 107

    (102) unary_op -> PLUS .

    THIS            reduce using rule 102 (unary_op -> PLUS .)
    SUPER           reduce using rule 102 (unary_op -> PLUS .)
    LPAREN          reduce using rule 102 (unary_op -> PLUS .)
    NEW             reduce using rule 102 (unary_op -> PLUS .)
    DOUBLE_PLUS     reduce using rule 102 (unary_op -> PLUS .)
    DOUBLE_MINUS    reduce using rule 102 (unary_op -> PLUS .)
    PLUS            reduce using rule 102 (unary_op -> PLUS .)
    MINUS           reduce using rule 102 (unary_op -> PLUS .)
    NOT             reduce using rule 102 (unary_op -> PLUS .)
    INT_CONST       reduce using rule 102 (unary_op -> PLUS .)
    FLOAT_CONST     reduce using rule 102 (unary_op -> PLUS .)
    STRING_CONST    reduce using rule 102 (unary_op -> PLUS .)
    NULL            reduce using rule 102 (unary_op -> PLUS .)
    TRUE            reduce using rule 102 (unary_op -> PLUS .)
    FALSE           reduce using rule 102 (unary_op -> PLUS .)
    ID              reduce using rule 102 (unary_op -> PLUS .)


state 108

    (103) unary_op -> MINUS .

    THIS            reduce using rule 103 (unary_op -> MINUS .)
    SUPER           reduce using rule 103 (unary_op -> MINUS .)
    LPAREN          reduce using rule 103 (unary_op -> MINUS .)
    NEW             reduce using rule 103 (unary_op -> MINUS .)
    DOUBLE_PLUS     reduce using rule 103 (unary_op -> MINUS .)
    DOUBLE_MINUS    reduce using rule 103 (unary_op -> MINUS .)
    PLUS            reduce using rule 103 (unary_op -> MINUS .)
    MINUS           reduce using rule 103 (unary_op -> MINUS .)
    NOT             reduce using rule 103 (unary_op -> MINUS .)
    INT_CONST       reduce using rule 103 (unary_op -> MINUS .)
    FLOAT_CONST     reduce using rule 103 (unary_op -> MINUS .)
    STRING_CONST    reduce using rule 103 (unary_op -> MINUS .)
    NULL            reduce using rule 103 (unary_op -> MINUS .)
    TRUE            reduce using rule 103 (unary_op -> MINUS .)
    FALSE           reduce using rule 103 (unary_op -> MINUS .)
    ID              reduce using rule 103 (unary_op -> MINUS .)


state 109

    (104) unary_op -> NOT .

    THIS            reduce using rule 104 (unary_op -> NOT .)
    SUPER           reduce using rule 104 (unary_op -> NOT .)
    LPAREN          reduce using rule 104 (unary_op -> NOT .)
    NEW             reduce using rule 104 (unary_op -> NOT .)
    DOUBLE_PLUS     reduce using rule 104 (unary_op -> NOT .)
    DOUBLE_MINUS    reduce using rule 104 (unary_op -> NOT .)
    PLUS            reduce using rule 104 (unary_op -> NOT .)
    MINUS           reduce using rule 104 (unary_op -> NOT .)
    NOT             reduce using rule 104 (unary_op -> NOT .)
    INT_CONST       reduce using rule 104 (unary_op -> NOT .)
    FLOAT_CONST     reduce using rule 104 (unary_op -> NOT .)
    STRING_CONST    reduce using rule 104 (unary_op -> NOT .)
    NULL            reduce using rule 104 (unary_op -> NOT .)
    TRUE            reduce using rule 104 (unary_op -> NOT .)
    FALSE           reduce using rule 104 (unary_op -> NOT .)
    ID              reduce using rule 104 (unary_op -> NOT .)


state 110

    (74) lhs -> field_access .
    (77) method_invocation -> field_access . LPAREN opt_args_alt RPAREN

    EQUALS          reduce using rule 74 (lhs -> field_access .)
    DOUBLE_PLUS     reduce using rule 74 (lhs -> field_access .)
    DOUBLE_MINUS    reduce using rule 74 (lhs -> field_access .)
    DOT             reduce using rule 74 (lhs -> field_access .)
    RPAREN          reduce using rule 74 (lhs -> field_access .)
    PLUS            reduce using rule 74 (lhs -> field_access .)
    MINUS           reduce using rule 74 (lhs -> field_access .)
    TIMES           reduce using rule 74 (lhs -> field_access .)
    DIVIDE          reduce using rule 74 (lhs -> field_access .)
    AND             reduce using rule 74 (lhs -> field_access .)
    OR              reduce using rule 74 (lhs -> field_access .)
    DOUBLE_EQUALS   reduce using rule 74 (lhs -> field_access .)
    NOT_EQUAL       reduce using rule 74 (lhs -> field_access .)
    L_EQ            reduce using rule 74 (lhs -> field_access .)
    G_EQ            reduce using rule 74 (lhs -> field_access .)
    LESS            reduce using rule 74 (lhs -> field_access .)
    GREATER         reduce using rule 74 (lhs -> field_access .)
    SEMICOLON       reduce using rule 74 (lhs -> field_access .)
    COMMA           reduce using rule 74 (lhs -> field_access .)
    LPAREN          shift and go to state 124


state 111

    (42) stmt -> WHILE LPAREN . expr RPAREN stmt
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    expr                           shift and go to state 144
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 112

    (43) stmt -> FOR LPAREN . opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt
    (55) opt_stmt_expr -> . stmt_expr
    (56) opt_stmt_expr -> . empty
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (1) empty -> .
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    SEMICOLON       reduce using rule 1 (empty -> .)
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    ID              shift and go to state 104
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    opt_stmt_expr                  shift and go to state 145
    stmt_expr                      shift and go to state 146
    empty                          shift and go to state 147
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 113

    (44) stmt -> RETURN opt_expr . SEMICOLON

    SEMICOLON       shift and go to state 148


state 114

    (53) opt_expr -> expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

    SEMICOLON       reduce using rule 53 (opt_expr -> expr .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 115

    (54) opt_expr -> empty .

    SEMICOLON       reduce using rule 54 (opt_expr -> empty .)


state 116

    (45) stmt -> stmt_expr SEMICOLON .

    RBRACK          reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    IF              reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    LBRACK          reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    DOUBLE_PLUS     reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    DOUBLE_MINUS    reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 45 (stmt -> stmt_expr SEMICOLON .)


state 117

    (46) stmt -> BREAK SEMICOLON .

    RBRACK          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    LBRACK          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    DOUBLE_PLUS     reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    DOUBLE_MINUS    reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    STRING_CONST    reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 46 (stmt -> BREAK SEMICOLON .)


state 118

    (47) stmt -> CONTINUE SEMICOLON .

    RBRACK          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    LBRACK          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    DOUBLE_PLUS     reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    DOUBLE_MINUS    reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    STRING_CONST    reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)


state 119

    (85) assign -> lhs EQUALS . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    lhs                            shift and go to state 105
    expr                           shift and go to state 149
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 120

    (86) assign -> lhs DOUBLE_PLUS .

    SEMICOLON       reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    RPAREN          reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    PLUS            reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    MINUS           reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    TIMES           reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    DIVIDE          reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    AND             reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    OR              reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    DOUBLE_EQUALS   reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    NOT_EQUAL       reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    L_EQ            reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    G_EQ            reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    LESS            reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    GREATER         reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)
    COMMA           reduce using rule 86 (assign -> lhs DOUBLE_PLUS .)


state 121

    (88) assign -> lhs DOUBLE_MINUS .

    SEMICOLON       reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    RPAREN          reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    PLUS            reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    MINUS           reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    TIMES           reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    DIVIDE          reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    AND             reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    OR              reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    DOUBLE_EQUALS   reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    NOT_EQUAL       reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    L_EQ            reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    G_EQ            reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    LESS            reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    GREATER         reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)
    COMMA           reduce using rule 88 (assign -> lhs DOUBLE_MINUS .)


state 122

    (87) assign -> DOUBLE_PLUS lhs .
    (68) primary -> lhs .

    SEMICOLON       reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    RPAREN          reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    PLUS            reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    MINUS           reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    TIMES           reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    DIVIDE          reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    AND             reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    OR              reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    DOUBLE_EQUALS   reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    NOT_EQUAL       reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    L_EQ            reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    G_EQ            reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    LESS            reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    GREATER         reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    COMMA           reduce using rule 87 (assign -> DOUBLE_PLUS lhs .)
    DOT             reduce using rule 68 (primary -> lhs .)


state 123

    (89) assign -> DOUBLE_MINUS lhs .
    (68) primary -> lhs .

    SEMICOLON       reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    RPAREN          reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    PLUS            reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    MINUS           reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    TIMES           reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    DIVIDE          reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    AND             reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    OR              reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    DOUBLE_EQUALS   reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    NOT_EQUAL       reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    L_EQ            reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    G_EQ            reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    LESS            reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    GREATER         reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    COMMA           reduce using rule 89 (assign -> DOUBLE_MINUS lhs .)
    DOT             reduce using rule 68 (primary -> lhs .)


state 124

    (77) method_invocation -> field_access LPAREN . opt_args_alt RPAREN
    (78) opt_args_alt -> . arguments
    (79) opt_args_alt -> . empty
    (72) arguments -> . arguments COMMA expr
    (73) arguments -> . expr
    (1) empty -> .
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    RPAREN          reduce using rule 1 (empty -> .)
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    field_access                   shift and go to state 110
    opt_args_alt                   shift and go to state 150
    arguments                      shift and go to state 151
    empty                          shift and go to state 152
    expr                           shift and go to state 153
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106

state 125

    (75) field_access -> primary DOT . ID

    ID              shift and go to state 154


state 126

    (67) primary -> NEW ID . LPAREN opt_args RPAREN

    LPAREN          shift and go to state 155


state 127

    (41) stmt -> IF LPAREN expr . RPAREN stmt opt_else_stmt
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

    RPAREN          shift and go to state 156
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 128

    (66) primary -> LPAREN expr RPAREN .

    DOT             reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    DOUBLE_EQUALS   reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    L_EQ            reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    G_EQ            reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    LESS            reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 66 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 66 (primary -> LPAREN expr RPAREN .)


state 129

    (82) expr -> expr arith_op . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    expr                           shift and go to state 157
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 130

    (83) expr -> expr bool_op . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    expr                           shift and go to state 158
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 131

    (90) arith_op -> PLUS .

    THIS            reduce using rule 90 (arith_op -> PLUS .)
    SUPER           reduce using rule 90 (arith_op -> PLUS .)
    LPAREN          reduce using rule 90 (arith_op -> PLUS .)
    NEW             reduce using rule 90 (arith_op -> PLUS .)
    DOUBLE_PLUS     reduce using rule 90 (arith_op -> PLUS .)
    DOUBLE_MINUS    reduce using rule 90 (arith_op -> PLUS .)
    PLUS            reduce using rule 90 (arith_op -> PLUS .)
    MINUS           reduce using rule 90 (arith_op -> PLUS .)
    NOT             reduce using rule 90 (arith_op -> PLUS .)
    INT_CONST       reduce using rule 90 (arith_op -> PLUS .)
    FLOAT_CONST     reduce using rule 90 (arith_op -> PLUS .)
    STRING_CONST    reduce using rule 90 (arith_op -> PLUS .)
    NULL            reduce using rule 90 (arith_op -> PLUS .)
    TRUE            reduce using rule 90 (arith_op -> PLUS .)
    FALSE           reduce using rule 90 (arith_op -> PLUS .)
    ID              reduce using rule 90 (arith_op -> PLUS .)


state 132

    (91) arith_op -> MINUS .

    THIS            reduce using rule 91 (arith_op -> MINUS .)
    SUPER           reduce using rule 91 (arith_op -> MINUS .)
    LPAREN          reduce using rule 91 (arith_op -> MINUS .)
    NEW             reduce using rule 91 (arith_op -> MINUS .)
    DOUBLE_PLUS     reduce using rule 91 (arith_op -> MINUS .)
    DOUBLE_MINUS    reduce using rule 91 (arith_op -> MINUS .)
    PLUS            reduce using rule 91 (arith_op -> MINUS .)
    MINUS           reduce using rule 91 (arith_op -> MINUS .)
    NOT             reduce using rule 91 (arith_op -> MINUS .)
    INT_CONST       reduce using rule 91 (arith_op -> MINUS .)
    FLOAT_CONST     reduce using rule 91 (arith_op -> MINUS .)
    STRING_CONST    reduce using rule 91 (arith_op -> MINUS .)
    NULL            reduce using rule 91 (arith_op -> MINUS .)
    TRUE            reduce using rule 91 (arith_op -> MINUS .)
    FALSE           reduce using rule 91 (arith_op -> MINUS .)
    ID              reduce using rule 91 (arith_op -> MINUS .)


state 133

    (92) arith_op -> TIMES .

    THIS            reduce using rule 92 (arith_op -> TIMES .)
    SUPER           reduce using rule 92 (arith_op -> TIMES .)
    LPAREN          reduce using rule 92 (arith_op -> TIMES .)
    NEW             reduce using rule 92 (arith_op -> TIMES .)
    DOUBLE_PLUS     reduce using rule 92 (arith_op -> TIMES .)
    DOUBLE_MINUS    reduce using rule 92 (arith_op -> TIMES .)
    PLUS            reduce using rule 92 (arith_op -> TIMES .)
    MINUS           reduce using rule 92 (arith_op -> TIMES .)
    NOT             reduce using rule 92 (arith_op -> TIMES .)
    INT_CONST       reduce using rule 92 (arith_op -> TIMES .)
    FLOAT_CONST     reduce using rule 92 (arith_op -> TIMES .)
    STRING_CONST    reduce using rule 92 (arith_op -> TIMES .)
    NULL            reduce using rule 92 (arith_op -> TIMES .)
    TRUE            reduce using rule 92 (arith_op -> TIMES .)
    FALSE           reduce using rule 92 (arith_op -> TIMES .)
    ID              reduce using rule 92 (arith_op -> TIMES .)


state 134

    (93) arith_op -> DIVIDE .

    THIS            reduce using rule 93 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 93 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 93 (arith_op -> DIVIDE .)
    NEW             reduce using rule 93 (arith_op -> DIVIDE .)
    DOUBLE_PLUS     reduce using rule 93 (arith_op -> DIVIDE .)
    DOUBLE_MINUS    reduce using rule 93 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 93 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 93 (arith_op -> DIVIDE .)
    NOT             reduce using rule 93 (arith_op -> DIVIDE .)
    INT_CONST       reduce using rule 93 (arith_op -> DIVIDE .)
    FLOAT_CONST     reduce using rule 93 (arith_op -> DIVIDE .)
    STRING_CONST    reduce using rule 93 (arith_op -> DIVIDE .)
    NULL            reduce using rule 93 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 93 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 93 (arith_op -> DIVIDE .)
    ID              reduce using rule 93 (arith_op -> DIVIDE .)


state 135

    (94) bool_op -> AND .

    THIS            reduce using rule 94 (bool_op -> AND .)
    SUPER           reduce using rule 94 (bool_op -> AND .)
    LPAREN          reduce using rule 94 (bool_op -> AND .)
    NEW             reduce using rule 94 (bool_op -> AND .)
    DOUBLE_PLUS     reduce using rule 94 (bool_op -> AND .)
    DOUBLE_MINUS    reduce using rule 94 (bool_op -> AND .)
    PLUS            reduce using rule 94 (bool_op -> AND .)
    MINUS           reduce using rule 94 (bool_op -> AND .)
    NOT             reduce using rule 94 (bool_op -> AND .)
    INT_CONST       reduce using rule 94 (bool_op -> AND .)
    FLOAT_CONST     reduce using rule 94 (bool_op -> AND .)
    STRING_CONST    reduce using rule 94 (bool_op -> AND .)
    NULL            reduce using rule 94 (bool_op -> AND .)
    TRUE            reduce using rule 94 (bool_op -> AND .)
    FALSE           reduce using rule 94 (bool_op -> AND .)
    ID              reduce using rule 94 (bool_op -> AND .)


state 136

    (95) bool_op -> OR .

    THIS            reduce using rule 95 (bool_op -> OR .)
    SUPER           reduce using rule 95 (bool_op -> OR .)
    LPAREN          reduce using rule 95 (bool_op -> OR .)
    NEW             reduce using rule 95 (bool_op -> OR .)
    DOUBLE_PLUS     reduce using rule 95 (bool_op -> OR .)
    DOUBLE_MINUS    reduce using rule 95 (bool_op -> OR .)
    PLUS            reduce using rule 95 (bool_op -> OR .)
    MINUS           reduce using rule 95 (bool_op -> OR .)
    NOT             reduce using rule 95 (bool_op -> OR .)
    INT_CONST       reduce using rule 95 (bool_op -> OR .)
    FLOAT_CONST     reduce using rule 95 (bool_op -> OR .)
    STRING_CONST    reduce using rule 95 (bool_op -> OR .)
    NULL            reduce using rule 95 (bool_op -> OR .)
    TRUE            reduce using rule 95 (bool_op -> OR .)
    FALSE           reduce using rule 95 (bool_op -> OR .)
    ID              reduce using rule 95 (bool_op -> OR .)


state 137

    (96) bool_op -> DOUBLE_EQUALS .

    THIS            reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    SUPER           reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    LPAREN          reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    NEW             reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    DOUBLE_PLUS     reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    DOUBLE_MINUS    reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    PLUS            reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    MINUS           reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    NOT             reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    INT_CONST       reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    FLOAT_CONST     reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    STRING_CONST    reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    NULL            reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    TRUE            reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    FALSE           reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)
    ID              reduce using rule 96 (bool_op -> DOUBLE_EQUALS .)


state 138

    (97) bool_op -> NOT_EQUAL .

    THIS            reduce using rule 97 (bool_op -> NOT_EQUAL .)
    SUPER           reduce using rule 97 (bool_op -> NOT_EQUAL .)
    LPAREN          reduce using rule 97 (bool_op -> NOT_EQUAL .)
    NEW             reduce using rule 97 (bool_op -> NOT_EQUAL .)
    DOUBLE_PLUS     reduce using rule 97 (bool_op -> NOT_EQUAL .)
    DOUBLE_MINUS    reduce using rule 97 (bool_op -> NOT_EQUAL .)
    PLUS            reduce using rule 97 (bool_op -> NOT_EQUAL .)
    MINUS           reduce using rule 97 (bool_op -> NOT_EQUAL .)
    NOT             reduce using rule 97 (bool_op -> NOT_EQUAL .)
    INT_CONST       reduce using rule 97 (bool_op -> NOT_EQUAL .)
    FLOAT_CONST     reduce using rule 97 (bool_op -> NOT_EQUAL .)
    STRING_CONST    reduce using rule 97 (bool_op -> NOT_EQUAL .)
    NULL            reduce using rule 97 (bool_op -> NOT_EQUAL .)
    TRUE            reduce using rule 97 (bool_op -> NOT_EQUAL .)
    FALSE           reduce using rule 97 (bool_op -> NOT_EQUAL .)
    ID              reduce using rule 97 (bool_op -> NOT_EQUAL .)


state 139

    (98) bool_op -> L_EQ .

    THIS            reduce using rule 98 (bool_op -> L_EQ .)
    SUPER           reduce using rule 98 (bool_op -> L_EQ .)
    LPAREN          reduce using rule 98 (bool_op -> L_EQ .)
    NEW             reduce using rule 98 (bool_op -> L_EQ .)
    DOUBLE_PLUS     reduce using rule 98 (bool_op -> L_EQ .)
    DOUBLE_MINUS    reduce using rule 98 (bool_op -> L_EQ .)
    PLUS            reduce using rule 98 (bool_op -> L_EQ .)
    MINUS           reduce using rule 98 (bool_op -> L_EQ .)
    NOT             reduce using rule 98 (bool_op -> L_EQ .)
    INT_CONST       reduce using rule 98 (bool_op -> L_EQ .)
    FLOAT_CONST     reduce using rule 98 (bool_op -> L_EQ .)
    STRING_CONST    reduce using rule 98 (bool_op -> L_EQ .)
    NULL            reduce using rule 98 (bool_op -> L_EQ .)
    TRUE            reduce using rule 98 (bool_op -> L_EQ .)
    FALSE           reduce using rule 98 (bool_op -> L_EQ .)
    ID              reduce using rule 98 (bool_op -> L_EQ .)


state 140

    (99) bool_op -> G_EQ .

    THIS            reduce using rule 99 (bool_op -> G_EQ .)
    SUPER           reduce using rule 99 (bool_op -> G_EQ .)
    LPAREN          reduce using rule 99 (bool_op -> G_EQ .)
    NEW             reduce using rule 99 (bool_op -> G_EQ .)
    DOUBLE_PLUS     reduce using rule 99 (bool_op -> G_EQ .)
    DOUBLE_MINUS    reduce using rule 99 (bool_op -> G_EQ .)
    PLUS            reduce using rule 99 (bool_op -> G_EQ .)
    MINUS           reduce using rule 99 (bool_op -> G_EQ .)
    NOT             reduce using rule 99 (bool_op -> G_EQ .)
    INT_CONST       reduce using rule 99 (bool_op -> G_EQ .)
    FLOAT_CONST     reduce using rule 99 (bool_op -> G_EQ .)
    STRING_CONST    reduce using rule 99 (bool_op -> G_EQ .)
    NULL            reduce using rule 99 (bool_op -> G_EQ .)
    TRUE            reduce using rule 99 (bool_op -> G_EQ .)
    FALSE           reduce using rule 99 (bool_op -> G_EQ .)
    ID              reduce using rule 99 (bool_op -> G_EQ .)


state 141

    (100) bool_op -> LESS .

    THIS            reduce using rule 100 (bool_op -> LESS .)
    SUPER           reduce using rule 100 (bool_op -> LESS .)
    LPAREN          reduce using rule 100 (bool_op -> LESS .)
    NEW             reduce using rule 100 (bool_op -> LESS .)
    DOUBLE_PLUS     reduce using rule 100 (bool_op -> LESS .)
    DOUBLE_MINUS    reduce using rule 100 (bool_op -> LESS .)
    PLUS            reduce using rule 100 (bool_op -> LESS .)
    MINUS           reduce using rule 100 (bool_op -> LESS .)
    NOT             reduce using rule 100 (bool_op -> LESS .)
    INT_CONST       reduce using rule 100 (bool_op -> LESS .)
    FLOAT_CONST     reduce using rule 100 (bool_op -> LESS .)
    STRING_CONST    reduce using rule 100 (bool_op -> LESS .)
    NULL            reduce using rule 100 (bool_op -> LESS .)
    TRUE            reduce using rule 100 (bool_op -> LESS .)
    FALSE           reduce using rule 100 (bool_op -> LESS .)
    ID              reduce using rule 100 (bool_op -> LESS .)


state 142

    (101) bool_op -> GREATER .

    THIS            reduce using rule 101 (bool_op -> GREATER .)
    SUPER           reduce using rule 101 (bool_op -> GREATER .)
    LPAREN          reduce using rule 101 (bool_op -> GREATER .)
    NEW             reduce using rule 101 (bool_op -> GREATER .)
    DOUBLE_PLUS     reduce using rule 101 (bool_op -> GREATER .)
    DOUBLE_MINUS    reduce using rule 101 (bool_op -> GREATER .)
    PLUS            reduce using rule 101 (bool_op -> GREATER .)
    MINUS           reduce using rule 101 (bool_op -> GREATER .)
    NOT             reduce using rule 101 (bool_op -> GREATER .)
    INT_CONST       reduce using rule 101 (bool_op -> GREATER .)
    FLOAT_CONST     reduce using rule 101 (bool_op -> GREATER .)
    STRING_CONST    reduce using rule 101 (bool_op -> GREATER .)
    NULL            reduce using rule 101 (bool_op -> GREATER .)
    TRUE            reduce using rule 101 (bool_op -> GREATER .)
    FALSE           reduce using rule 101 (bool_op -> GREATER .)
    ID              reduce using rule 101 (bool_op -> GREATER .)


state 143

    (84) expr -> unary_op expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for DOUBLE_EQUALS resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for L_EQ resolved as shift
  ! shift/reduce conflict for G_EQ resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    RPAREN          reduce using rule 84 (expr -> unary_op expr .)
    SEMICOLON       reduce using rule 84 (expr -> unary_op expr .)
    COMMA           reduce using rule 84 (expr -> unary_op expr .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

  ! PLUS            [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! MINUS           [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! TIMES           [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! DIVIDE          [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! AND             [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! OR              [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! DOUBLE_EQUALS   [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! NOT_EQUAL       [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! L_EQ            [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! G_EQ            [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! LESS            [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! GREATER         [ reduce using rule 84 (expr -> unary_op expr .) ]

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 144

    (42) stmt -> WHILE LPAREN expr . RPAREN stmt
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

    RPAREN          shift and go to state 159
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 145

    (43) stmt -> FOR LPAREN opt_stmt_expr . SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt

    SEMICOLON       shift and go to state 160


state 146

    (55) opt_stmt_expr -> stmt_expr .

    SEMICOLON       reduce using rule 55 (opt_stmt_expr -> stmt_expr .)
    RPAREN          reduce using rule 55 (opt_stmt_expr -> stmt_expr .)


state 147

    (56) opt_stmt_expr -> empty .

    SEMICOLON       reduce using rule 56 (opt_stmt_expr -> empty .)
    RPAREN          reduce using rule 56 (opt_stmt_expr -> empty .)


state 148

    (44) stmt -> RETURN opt_expr SEMICOLON .

    RBRACK          reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    IF              reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    WHILE           reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    FOR             reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    RETURN          reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    BREAK           reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    CONTINUE        reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    LBRACK          reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    DOUBLE_PLUS     reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    DOUBLE_MINUS    reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    INT             reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    FLOAT           reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    ID              reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    THIS            reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    SUPER           reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    LPAREN          reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    NEW             reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    INT_CONST       reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    NULL            reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    TRUE            reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    FALSE           reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)
    ELSE            reduce using rule 44 (stmt -> RETURN opt_expr SEMICOLON .)


state 149

    (85) assign -> lhs EQUALS expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

    SEMICOLON       reduce using rule 85 (assign -> lhs EQUALS expr .)
    RPAREN          reduce using rule 85 (assign -> lhs EQUALS expr .)
    COMMA           reduce using rule 85 (assign -> lhs EQUALS expr .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

  ! PLUS            [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! MINUS           [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! TIMES           [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! AND             [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! OR              [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! DOUBLE_EQUALS   [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! NOT_EQUAL       [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! L_EQ            [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! G_EQ            [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! LESS            [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! GREATER         [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 150

    (77) method_invocation -> field_access LPAREN opt_args_alt . RPAREN

    RPAREN          shift and go to state 161


state 151

    (78) opt_args_alt -> arguments .
    (72) arguments -> arguments . COMMA expr

    RPAREN          reduce using rule 78 (opt_args_alt -> arguments .)
    COMMA           shift and go to state 162


state 152

    (79) opt_args_alt -> empty .

    RPAREN          reduce using rule 79 (opt_args_alt -> empty .)


state 153

    (73) arguments -> expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

    COMMA           reduce using rule 73 (arguments -> expr .)
    RPAREN          reduce using rule 73 (arguments -> expr .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 154

    (75) field_access -> primary DOT ID .

    LPAREN          reduce using rule 75 (field_access -> primary DOT ID .)
    EQUALS          reduce using rule 75 (field_access -> primary DOT ID .)
    DOUBLE_PLUS     reduce using rule 75 (field_access -> primary DOT ID .)
    DOUBLE_MINUS    reduce using rule 75 (field_access -> primary DOT ID .)
    DOT             reduce using rule 75 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 75 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 75 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 75 (field_access -> primary DOT ID .)
    TIMES           reduce using rule 75 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 75 (field_access -> primary DOT ID .)
    AND             reduce using rule 75 (field_access -> primary DOT ID .)
    OR              reduce using rule 75 (field_access -> primary DOT ID .)
    DOUBLE_EQUALS   reduce using rule 75 (field_access -> primary DOT ID .)
    NOT_EQUAL       reduce using rule 75 (field_access -> primary DOT ID .)
    L_EQ            reduce using rule 75 (field_access -> primary DOT ID .)
    G_EQ            reduce using rule 75 (field_access -> primary DOT ID .)
    LESS            reduce using rule 75 (field_access -> primary DOT ID .)
    GREATER         reduce using rule 75 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 75 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 75 (field_access -> primary DOT ID .)


state 155

    (67) primary -> NEW ID LPAREN . opt_args RPAREN
    (70) opt_args -> . arguments
    (71) opt_args -> . empty
    (72) arguments -> . arguments COMMA expr
    (73) arguments -> . expr
    (1) empty -> .
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    RPAREN          reduce using rule 1 (empty -> .)
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    opt_args                       shift and go to state 163
    arguments                      shift and go to state 164
    empty                          shift and go to state 165
    expr                           shift and go to state 153
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 156

    (41) stmt -> IF LPAREN expr RPAREN . stmt opt_else_stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt opt_else_stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt
    (44) stmt -> . RETURN opt_expr SEMICOLON
    (45) stmt -> . stmt_expr SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (38) block -> . LBRACK stmt_mult RBRACK
    (20) var_decl -> . type variables SEMICOLON
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 74
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 73
    LBRACK          shift and go to state 60
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt                           shift and go to state 166
    stmt_expr                      shift and go to state 75
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 157

    (82) expr -> expr arith_op expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for DOUBLE_EQUALS resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for L_EQ resolved as shift
  ! shift/reduce conflict for G_EQ resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    RPAREN          reduce using rule 82 (expr -> expr arith_op expr .)
    SEMICOLON       reduce using rule 82 (expr -> expr arith_op expr .)
    COMMA           reduce using rule 82 (expr -> expr arith_op expr .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

  ! PLUS            [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! MINUS           [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! TIMES           [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! DIVIDE          [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! AND             [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! OR              [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! DOUBLE_EQUALS   [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! NOT_EQUAL       [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! L_EQ            [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! G_EQ            [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! LESS            [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! GREATER         [ reduce using rule 82 (expr -> expr arith_op expr .) ]

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 158

    (83) expr -> expr bool_op expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for DOUBLE_EQUALS resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for L_EQ resolved as shift
  ! shift/reduce conflict for G_EQ resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    RPAREN          reduce using rule 83 (expr -> expr bool_op expr .)
    SEMICOLON       reduce using rule 83 (expr -> expr bool_op expr .)
    COMMA           reduce using rule 83 (expr -> expr bool_op expr .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

  ! PLUS            [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! MINUS           [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! TIMES           [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! DIVIDE          [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! AND             [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! OR              [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! DOUBLE_EQUALS   [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! NOT_EQUAL       [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! L_EQ            [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! G_EQ            [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! LESS            [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! GREATER         [ reduce using rule 83 (expr -> expr bool_op expr .) ]

    bool_op                        shift and go to state 130
    arith_op                       shift and go to state 129

state 159

    (42) stmt -> WHILE LPAREN expr RPAREN . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt opt_else_stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt
    (44) stmt -> . RETURN opt_expr SEMICOLON
    (45) stmt -> . stmt_expr SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (38) block -> . LBRACK stmt_mult RBRACK
    (20) var_decl -> . type variables SEMICOLON
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 74
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 73
    LBRACK          shift and go to state 60
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt                           shift and go to state 167
    stmt_expr                      shift and go to state 75
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 160

    (43) stmt -> FOR LPAREN opt_stmt_expr SEMICOLON . opt_expr SEMICOLON opt_stmt_expr RPAREN stmt
    (53) opt_expr -> . expr
    (54) opt_expr -> . empty
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (1) empty -> .
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    SEMICOLON       reduce using rule 1 (empty -> .)
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    opt_expr                       shift and go to state 168
    expr                           shift and go to state 114
    empty                          shift and go to state 115
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 161

    (77) method_invocation -> field_access LPAREN opt_args_alt RPAREN .

    SEMICOLON       reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    DOT             reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    RPAREN          reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    PLUS            reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    MINUS           reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    TIMES           reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    DIVIDE          reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    AND             reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    OR              reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    DOUBLE_EQUALS   reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    NOT_EQUAL       reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    L_EQ            reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    G_EQ            reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    LESS            reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    GREATER         reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)
    COMMA           reduce using rule 77 (method_invocation -> field_access LPAREN opt_args_alt RPAREN .)


state 162

    (72) arguments -> arguments COMMA . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    NOT             shift and go to state 109
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 104

    expr                           shift and go to state 169
    primary                        shift and go to state 101
    assign                         shift and go to state 102
    unary_op                       shift and go to state 103
    literal                        shift and go to state 89
    lhs                            shift and go to state 105
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 110

state 163

    (67) primary -> NEW ID LPAREN opt_args . RPAREN

    RPAREN          shift and go to state 170


state 164

    (70) opt_args -> arguments .
    (72) arguments -> arguments . COMMA expr

    RPAREN          reduce using rule 70 (opt_args -> arguments .)
    COMMA           shift and go to state 162


state 165

    (71) opt_args -> empty .

    RPAREN          reduce using rule 71 (opt_args -> empty .)


state 166

    (41) stmt -> IF LPAREN expr RPAREN stmt . opt_else_stmt
    (51) opt_else_stmt -> . ELSE stmt
    (52) opt_else_stmt -> . empty
    (1) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 172
    RBRACK          reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    CONTINUE        reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    LBRACK          reduce using rule 1 (empty -> .)
    DOUBLE_PLUS     reduce using rule 1 (empty -> .)
    DOUBLE_MINUS    reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    THIS            reduce using rule 1 (empty -> .)
    SUPER           reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    NEW             reduce using rule 1 (empty -> .)
    INT_CONST       reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    STRING_CONST    reduce using rule 1 (empty -> .)
    NULL            reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)

  ! ELSE            [ reduce using rule 1 (empty -> .) ]

    opt_else_stmt                  shift and go to state 171
    empty                          shift and go to state 173

state 167

    (42) stmt -> WHILE LPAREN expr RPAREN stmt .

    RBRACK          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LBRACK          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    DOUBLE_PLUS     reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    DOUBLE_MINUS    reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)


state 168

    (43) stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr . SEMICOLON opt_stmt_expr RPAREN stmt

    SEMICOLON       shift and go to state 174


state 169

    (72) arguments -> arguments COMMA expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . DOUBLE_EQUALS
    (97) bool_op -> . NOT_EQUAL
    (98) bool_op -> . L_EQ
    (99) bool_op -> . G_EQ
    (100) bool_op -> . LESS
    (101) bool_op -> . GREATER

    COMMA           reduce using rule 72 (arguments -> arguments COMMA expr .)
    RPAREN          reduce using rule 72 (arguments -> arguments COMMA expr .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136
    DOUBLE_EQUALS   shift and go to state 137
    NOT_EQUAL       shift and go to state 138
    L_EQ            shift and go to state 139
    G_EQ            shift and go to state 140
    LESS            shift and go to state 141
    GREATER         shift and go to state 142

    arith_op                       shift and go to state 129
    bool_op                        shift and go to state 130

state 170

    (67) primary -> NEW ID LPAREN opt_args RPAREN .

    DOT             reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    RPAREN          reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    PLUS            reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    MINUS           reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    TIMES           reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    DIVIDE          reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    AND             reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    OR              reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    DOUBLE_EQUALS   reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    NOT_EQUAL       reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    L_EQ            reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    G_EQ            reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    LESS            reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    GREATER         reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    SEMICOLON       reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)
    COMMA           reduce using rule 67 (primary -> NEW ID LPAREN opt_args RPAREN .)


state 171

    (41) stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .

    RBRACK          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    IF              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    WHILE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    FOR             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    RETURN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    BREAK           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    CONTINUE        reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    SEMICOLON       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    LBRACK          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    DOUBLE_PLUS     reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    DOUBLE_MINUS    reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    INT             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    FLOAT           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    ID              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    THIS            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    SUPER           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    LPAREN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    NEW             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    INT_CONST       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    FLOAT_CONST     reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    STRING_CONST    reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    NULL            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    TRUE            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    FALSE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)
    ELSE            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt opt_else_stmt .)


state 172

    (51) opt_else_stmt -> ELSE . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt opt_else_stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt
    (44) stmt -> . RETURN opt_expr SEMICOLON
    (45) stmt -> . stmt_expr SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (38) block -> . LBRACK stmt_mult RBRACK
    (20) var_decl -> . type variables SEMICOLON
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 74
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 73
    LBRACK          shift and go to state 60
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt                           shift and go to state 175
    stmt_expr                      shift and go to state 75
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 173

    (52) opt_else_stmt -> empty .

    ELSE            reduce using rule 52 (opt_else_stmt -> empty .)
    RBRACK          reduce using rule 52 (opt_else_stmt -> empty .)
    IF              reduce using rule 52 (opt_else_stmt -> empty .)
    WHILE           reduce using rule 52 (opt_else_stmt -> empty .)
    FOR             reduce using rule 52 (opt_else_stmt -> empty .)
    RETURN          reduce using rule 52 (opt_else_stmt -> empty .)
    BREAK           reduce using rule 52 (opt_else_stmt -> empty .)
    CONTINUE        reduce using rule 52 (opt_else_stmt -> empty .)
    SEMICOLON       reduce using rule 52 (opt_else_stmt -> empty .)
    LBRACK          reduce using rule 52 (opt_else_stmt -> empty .)
    DOUBLE_PLUS     reduce using rule 52 (opt_else_stmt -> empty .)
    DOUBLE_MINUS    reduce using rule 52 (opt_else_stmt -> empty .)
    INT             reduce using rule 52 (opt_else_stmt -> empty .)
    FLOAT           reduce using rule 52 (opt_else_stmt -> empty .)
    BOOLEAN         reduce using rule 52 (opt_else_stmt -> empty .)
    ID              reduce using rule 52 (opt_else_stmt -> empty .)
    THIS            reduce using rule 52 (opt_else_stmt -> empty .)
    SUPER           reduce using rule 52 (opt_else_stmt -> empty .)
    LPAREN          reduce using rule 52 (opt_else_stmt -> empty .)
    NEW             reduce using rule 52 (opt_else_stmt -> empty .)
    INT_CONST       reduce using rule 52 (opt_else_stmt -> empty .)
    FLOAT_CONST     reduce using rule 52 (opt_else_stmt -> empty .)
    STRING_CONST    reduce using rule 52 (opt_else_stmt -> empty .)
    NULL            reduce using rule 52 (opt_else_stmt -> empty .)
    TRUE            reduce using rule 52 (opt_else_stmt -> empty .)
    FALSE           reduce using rule 52 (opt_else_stmt -> empty .)


state 174

    (43) stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON . opt_stmt_expr RPAREN stmt
    (55) opt_stmt_expr -> . stmt_expr
    (56) opt_stmt_expr -> . empty
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (1) empty -> .
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    RPAREN          reduce using rule 1 (empty -> .)
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    ID              shift and go to state 104
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    opt_stmt_expr                  shift and go to state 176
    stmt_expr                      shift and go to state 146
    empty                          shift and go to state 147
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 175

    (51) opt_else_stmt -> ELSE stmt .

    ELSE            reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    RBRACK          reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    IF              reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    WHILE           reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    FOR             reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    RETURN          reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    BREAK           reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    CONTINUE        reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    SEMICOLON       reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    LBRACK          reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    DOUBLE_PLUS     reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    DOUBLE_MINUS    reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    INT             reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    FLOAT           reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    BOOLEAN         reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    ID              reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    THIS            reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    SUPER           reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    LPAREN          reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    NEW             reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    INT_CONST       reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    FLOAT_CONST     reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    STRING_CONST    reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    NULL            reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    TRUE            reduce using rule 51 (opt_else_stmt -> ELSE stmt .)
    FALSE           reduce using rule 51 (opt_else_stmt -> ELSE stmt .)


state 176

    (43) stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 177


state 177

    (43) stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt opt_else_stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt
    (44) stmt -> . RETURN opt_expr SEMICOLON
    (45) stmt -> . stmt_expr SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (38) block -> . LBRACK stmt_mult RBRACK
    (20) var_decl -> . type variables SEMICOLON
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs DOUBLE_PLUS
    (87) assign -> . DOUBLE_PLUS lhs
    (88) assign -> . lhs DOUBLE_MINUS
    (89) assign -> . DOUBLE_MINUS lhs
    (77) method_invocation -> . field_access LPAREN opt_args_alt RPAREN
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . BOOLEAN
    (24) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (63) primary -> . literal
    (64) primary -> . THIS
    (65) primary -> . SUPER
    (66) primary -> . LPAREN expr RPAREN
    (67) primary -> . NEW ID LPAREN opt_args RPAREN
    (68) primary -> . lhs
    (69) primary -> . method_invocation
    (57) literal -> . INT_CONST
    (58) literal -> . FLOAT_CONST
    (59) literal -> . STRING_CONST
    (60) literal -> . NULL
    (61) literal -> . TRUE
    (62) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 74
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 73
    LBRACK          shift and go to state 60
    DOUBLE_PLUS     shift and go to state 84
    DOUBLE_MINUS    shift and go to state 85
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INT_CONST       shift and go to state 93
    FLOAT_CONST     shift and go to state 94
    STRING_CONST    shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt                           shift and go to state 178
    stmt_expr                      shift and go to state 75
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 178

    (43) stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .

    RBRACK          reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    IF              reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    FOR             reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    LBRACK          reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    DOUBLE_PLUS     reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    DOUBLE_MINUS    reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    INT             reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    ID              reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    THIS            reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    SUPER           reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    LPAREN          reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    NEW             reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    INT_CONST       reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    STRING_CONST    reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    NULL            reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    TRUE            reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    FALSE           reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 43 (stmt -> FOR LPAREN opt_stmt_expr SEMICOLON opt_expr SEMICOLON opt_stmt_expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 143 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 143 resolved as shift
WARNING: shift/reduce conflict for OR in state 143 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQUALS in state 143 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 143 resolved as shift
WARNING: shift/reduce conflict for L_EQ in state 143 resolved as shift
WARNING: shift/reduce conflict for G_EQ in state 143 resolved as shift
WARNING: shift/reduce conflict for LESS in state 143 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 143 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 157 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 157 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 157 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 157 resolved as shift
WARNING: shift/reduce conflict for AND in state 157 resolved as shift
WARNING: shift/reduce conflict for OR in state 157 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQUALS in state 157 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 157 resolved as shift
WARNING: shift/reduce conflict for L_EQ in state 157 resolved as shift
WARNING: shift/reduce conflict for G_EQ in state 157 resolved as shift
WARNING: shift/reduce conflict for LESS in state 157 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 157 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 158 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 158 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 158 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 158 resolved as shift
WARNING: shift/reduce conflict for AND in state 158 resolved as shift
WARNING: shift/reduce conflict for OR in state 158 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQUALS in state 158 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 158 resolved as shift
WARNING: shift/reduce conflict for L_EQ in state 158 resolved as shift
WARNING: shift/reduce conflict for G_EQ in state 158 resolved as shift
WARNING: shift/reduce conflict for LESS in state 158 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 158 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 166 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (empty -> <empty>)
WARNING: rejected rule (program -> class_decl) in state 2
WARNING: Rule (program -> class_decl) is never reduced
